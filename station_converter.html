<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpotConverter Pro (RijdendeTreinen Stijl)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts (Open Sans) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* RijdendeTreinen.nl Kleurenpalet en Font */
        :root {
            --rt-blue: #0d2a4c;
            --rt-orange: #f37736;
            --rt-light-blue: #e6f3f9;
            --rt-gray: #f0f0f0;
            --rt-text: #333;
        }
        body { 
            font-family: 'Open Sans', sans-serif; 
            background-color: var(--rt-gray);
            color: var(--rt-text);
        }
        .rt-header {
            background-color: var(--rt-blue);
            color: white;
            border-bottom: 5px solid var(--rt-orange);
        }
        .rt-button {
            background-color: var(--rt-orange);
            color: white;
            font-weight: 700;
            transition: background-color 0.2s;
        }
        .rt-button:hover {
            background-color: #d96323;
        }
        h2 {
            color: var(--rt-blue);
            font-weight: 700;
        }
        .info-box {
            background-color: var(--rt-light-blue);
            border-left: 4px solid var(--rt-orange);
            padding: 1rem 1.5rem;
        }
        .highlight-station { background-color: #d1eaff; padding: 0.1rem 0.3rem; border-radius: 0.2rem; font-weight: bold; }
        .highlight-abbr { 
            background-color: #e2e8f0; 
            color: #475569;
            padding: 0.1rem 0.3rem; 
            border-radius: 0.2rem; 
            font-weight: 600;
            cursor: help;
            border-bottom: 2px dotted #94a3b8;
        }
        .highlight-estimation { background-color: var(--rt-orange); padding: 0.1rem 0.3rem; border-radius: 0.2rem; font-weight: bold; color: white; }
        .toggle-btn {
            background: none;
            border: none;
            color: #64748b;
            font-weight: 600;
            cursor: pointer;
        }
        .toggle-btn:hover {
            color: var(--rt-blue);
        }
    </style>
</head>
<body class="py-8">
    <div class="max-w-4xl mx-auto px-4 space-y-8">
        
        <!-- Header en Toelichting -->
        <header class="rt-header p-6 rounded-lg shadow-lg text-center">
            <!-- ** NIEUW: Logo ** -->
            <div class="flex justify-center items-center mb-4">
                <svg width="80" height="80" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <path d="M20,75 H80" stroke="white" stroke-width="4" stroke-linecap="round"/>
                    <path d="M25,80 H75" stroke="white" stroke-width="2" stroke-dasharray="5,5"/>
                    <rect x="30" y="40" width="40" height="25" rx="5" fill="var(--rt-orange)"/>
                    <circle cx="40" cy="65" r="7" fill="white"/>
                    <circle cx="60" cy="65" r="7" fill="white"/>
                    <path d="M15,50 A 35 35 0 1 1 85,50" stroke="var(--rt-yellow)" stroke-width="6" fill="none" stroke-linecap="round"/>
                    <path d="M85,50 L90,45 M85,50 L90,55" stroke="var(--rt-yellow)" stroke-width="6" stroke-linecap="round"/>
                </svg>
            </div>
            <h1 class="text-4xl font-bold">SpotConverter Pro</h1>
            <p class="mt-2 text-lg text-gray-200">
                Deze tool helpt je om WhatsApp-berichten van treinspotters snel te analyseren. Plak een bericht en zie direct de volledige stationsnamen, de betekenis van spotters-jargon en een inschatting van de passage-tijd voor een gekozen station.
            </p>
        </header>

        <!-- Converter Tool -->
        <main class="bg-white p-6 rounded-lg shadow-md">
            <div class="grid md:grid-cols-2 gap-6">
                <!-- Input -->
                <div>
                    <label for="whatsappMessage" class="block text-lg font-bold text-gray-700 mb-2">Plak je WhatsApp bericht hier:</label>
                    <textarea id="whatsappMessage" class="w-full h-32 border-gray-300 rounded-md shadow-sm" placeholder="Bijv. 14:00 Hgl ri Amf" oninput="debounceProcessMessage()"></textarea>
                </div>
                <!-- Instellingen -->
                <div>
                    <label for="targetStationSelect" class="block text-lg font-bold text-gray-700 mb-2">Bereken passage voor:</label>
                    <select id="targetStationSelect" class="w-full border-gray-300 rounded-md shadow-sm" onchange="processMessage()"></select>
                </div>
            </div>
            
            <!-- Output secties -->
            <div class="mt-6 space-y-4">
                <div>
                    <h2 class="text-2xl mb-2">Verwerkt Bericht:</h2>
                    <div id="output" class="p-4 bg-gray-50 rounded-md min-h-[50px]"></div>
                </div>
                <div>
                    <h2 class="text-2xl mb-2">Analyse:</h2>
                    <div id="estimation-output" class="p-4 bg-gray-50 rounded-md min-h-[50px] info-box space-y-2"></div>
                </div>
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <h2 class="text-2xl">Geparsede Data (voor analyse)</h2>
                        <button id="toggle-data-btn" onclick="toggleParsedData()" class="toggle-btn">(Toon)</button>
                    </div>
                    <pre id="parsed-data-output" class="p-4 bg-gray-800 text-white text-xs rounded-md overflow-x-auto" style="display: none;"></pre>
                </div>
            </div>
        </main>
        
        <!-- Informatie sectie -->
        <footer class="bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-2xl mb-4">Terugkerende Treinpatronen</h2>
            <div class="space-y-4 text-gray-800">
                 <div>
                    <h4 class="font-bold text-xl">1. De "Katy Shuttle" (RFO)</h4>
                    <p class="pl-4">Deze shuttle is een van de meest frequente treinen op de Bentheimroute en verbindt Knooppunt Kijfhoek met Polen.</p>
                    <ul class="list-disc pl-10 mt-2">
                        <li><strong>Richting West (Nederland in):</strong> Volgt het traject `Duitsland-Amersfoort` en vervolgens `Amersfoort-Rotterdam`. Wordt vaak in de <strong>ochtend en vroege middag</strong> gespot.</li>
                        <li><strong>Richting Oost (Nederland uit):</strong> Volgt de omgekeerde route. Meestal gespot in de <strong>late middag en avond</strong> (16:00-18:00) rond Amersfoort.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-bold text-xl">2. De "PCC Shuttle" (RTB Cargo)</h4>
                    <p class="pl-4">Deze shuttle verbindt de Rotterdamse haven met Polen en is een vaste verschijning.</p>
                     <ul class="list-disc pl-10 mt-2">
                        <li><strong>Richting West (Nederland in):</strong> Volgt het traject `Duitsland-Amersfoort` en `Amersfoort-Rotterdam`. Meestal gespot in de <strong>ochtenduren</strong>.</li>
                        <li><strong>Richting Oost (Nederland uit):</strong> Volgt de omgekeerde route. Vaak gespot in de <strong>middag</strong> (14:00-17:00).</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-bold text-xl">3. De "Volvo Trein" (Lineas)</h4>
                    <p class="pl-4">Een vaste shuttle tussen Gent (BelgiÃ«) en Zweden. Deze trein volgt een zuidelijkere route en passeert de kern van de Bentheimroute vaak via Deventer en Zutphen.</p>
                     <ul class="list-disc pl-10 mt-2">
                        <li><strong>Richting West (Nederland in):</strong> Komt binnen via het traject `Duitsland-Amersfoort` tot aan Deventer/Zutphen. Vaak gespot in de <strong>vroege ochtend</strong> (07:00-09:00).</li>
                        <li><strong>Richting Oost (Nederland uit):</strong> Verlaat Nederland via het traject `Duitsland-Amersfoort`. Meestal gespot in de <strong>late middag/vroege avond</strong> (18:00-19:00).</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-bold text-xl">4. De "UC Onnen" & "UC Buna Werke" (DB Cargo)</h4>
                     <p class="pl-4">Dit zijn keteltreinen van DB Cargo met een zeer variabel, maar frequent patroon.</p>
                     <ul class="list-disc pl-10 mt-2">
                        <li><strong>Route:</strong> Rijden voornamelijk op het traject `Duitsland-Amersfoort` en buigen vaak af richting het noorden (Onnen) of blijven op de hoofdroute.</li>
                        <li><strong>Tijden:</strong> Deze treinen hebben geen vast tijdspatroon en kunnen op <strong>elk moment van de dag</strong> worden gespot in beide richtingen.</li>
                    </ul>
                </div>
            </div>
        </footer>

    </div>

    <script>
        // --- Globale variabelen en Constanten ---
        let stationData = [], distanceData = {}, trajectories = {}, debounceTimer;
        const spotterAbbr = {
            'A': 'Aankomst', 'V': 'Vertrek', 'D': 'Doorrijden',
            'LSP': 'Linkerspoor', 'LLSP': 'Linker-linkerspoor', 'MSP': 'Middenspoor',
            'RSP': 'Rechterspoor', 'RRSP': 'Rechter-rechterspoor',
            'NVR': 'Niet voor reizigers', 'LM': 'Leeg materieel', 'LLT': 'Losse loc trein',
            'SMS': 'Samenstelling', 'GE': 'Goederenemplacement', 'Badl': 'Beladen aan de loc'
        };
        const conflictingAbbrs = ['EN', 'DE', 'D', 'A', 'V', 'OP', 'ALS'];
        const germanStationCodes = ["RHEINE", "SALZBERGEN", "BH"];

        // --- Data Laden ---
        async function loadExternalData() {
            try {
                // Stations
                const stationsUrl = 'https://raw.githubusercontent.com/meijbaard/SpotConverter/main/stations.csv';
                const stationResponse = await fetch(stationsUrl);
                if (!stationResponse.ok) throw new Error(`Fout bij laden stations.csv: ${stationResponse.statusText}`);
                const stationCsvText = await stationResponse.text();
                const stationLines = stationCsvText.trim().split('\n');
                const stationHeaders = stationLines.shift().split(',').map(h => h.trim());
                const codeIndex = stationHeaders.indexOf('code');
                const nameLongIndex = stationHeaders.indexOf('name_long');
                if (codeIndex === -1 || nameLongIndex === -1) throw new Error("Kolommen 'code' en 'name_long' niet gevonden in stations.csv");
                stationData = stationLines.map(line => {
                    const values = line.split(',');
                    return { afkorting: values[codeIndex].trim().toUpperCase(), naam: values[nameLongIndex].trim().replace(/"/g, '') };
                });
                populateStationDropdown();

                // Afstanden
                const distancesUrl = 'https://raw.githubusercontent.com/meijbaard/SpotConverter/main/afstanden.csv';
                const distanceResponse = await fetch(distancesUrl);
                if (!distanceResponse.ok) throw new Error(`Fout bij laden afstanden.csv: ${distanceResponse.statusText}`);
                const distanceCsvText = await distanceResponse.text();
                const distanceLines = distanceCsvText.trim().split('\n');
                const distanceHeaders = distanceLines.shift().split(',').map(h => h.trim().toUpperCase());
                distanceData = {};
                distanceLines.forEach(line => {
                    const values = line.split(',');
                    const rowStationCode = values.shift().trim().toUpperCase();
                    distanceData[rowStationCode] = {};
                    values.forEach((dist, index) => {
                        const colStationCode = distanceHeaders[index + 1];
                        if (colStationCode) {
                            distanceData[rowStationCode][colStationCode] = parseFloat(dist);
                        }
                    });
                });
                
                // Trajecten
                trajectories = {
                    "Duitsland-Amersfoort": ["RHEINE", "SALZBERGEN", "BH", "ODZ", "HGLO", "HGL", "BN", "AMRI", "AML", "WDN", "RSN", "HON", "DVC", "DV", "TWL", "APDO", "APD", "STO", "BNVA", "BNV", "AMF"],
                    "Amersfoort-Amsterdam": ["AMF", "BRN", "HVS", "HVSM", "BSMZ", "NDB", "WP", "DMN", "ASSP", "ASDM", "ASD", "AWH"],
                    "Amersfoort-Rotterdam": ["AMF", "BRN", "HVS", "HVSM", "BSMZ", "NDB", "WP", "DMNZ", "ASB", "BKL", "WD", "GD", "RTN", "RTD"]
                };

            } catch (error) {
                console.error("Kon externe data niet laden:", error);
                document.getElementById('output').innerHTML = `<p class="warning">Kon de data van GitHub niet laden: ${error.message}</p>`;
            }
        }
        
        // --- UI Functies ---
        function populateStationDropdown() {
            const select = document.getElementById('targetStationSelect');
            select.innerHTML = '';
            stationData.sort((a,b) => a.naam.localeCompare(b.naam)).forEach(station => {
                const option = document.createElement('option');
                option.value = station.naam;
                option.textContent = station.naam;
                if (station.naam === "Baarn") option.selected = true;
                select.appendChild(option);
            });
        }

        function toggleParsedData() {
            const dataOutput = document.getElementById('parsed-data-output');
            const toggleBtn = document.getElementById('toggle-data-btn');
            const isHidden = dataOutput.style.display === 'none';
            dataOutput.style.display = isHidden ? 'block' : 'none';
            toggleBtn.textContent = isHidden ? '(Verberg)' : '(Toon)';
        }

        // --- Logica ---
        function findTrajectoryForRoute(routeCodes) {
            if (routeCodes.length < 2) return null;

            const isSubsequence = (sub, main) => {
                let i = 0, j = 0;
                while (i < main.length && j < sub.length) {
                    if (main[i] === sub[j]) j++;
                    i++;
                }
                return j === sub.length;
            };

            for (const name in trajectories) {
                const traject = trajectories[name];
                if (isSubsequence(routeCodes, traject)) {
                    return { name: name, direction: 'forward' };
                }
                if (isSubsequence(routeCodes, [...traject].reverse())) {
                    return { name: name, direction: 'backward' };
                }
            }

            const startCode = routeCodes[0];
            const endCode = routeCodes[routeCodes.length - 1];
            const hub = "AMF";

            const startTrajectNames = Object.keys(trajectories).filter(name => trajectories[name].includes(startCode));
            const endTrajectNames = Object.keys(trajectories).filter(name => trajectories[name].includes(endCode));

            for (const startName of startTrajectNames) {
                for (const endName of endTrajectNames) {
                    if (startName === endName) continue;

                    const startTraj = trajectories[startName];
                    const endTraj = trajectories[endName];

                    if (startTraj.includes(hub) && endTraj.includes(hub)) {
                        if (isSubsequence([startCode, hub], startTraj) && isSubsequence([hub, endCode], endTraj)) {
                            return { name: `${startName} -> ${endName}`, direction: 'forward' };
                        }
                         if (isSubsequence([startCode, hub], endTraj) && isSubsequence([hub, endCode], startTraj)) {
                            return { name: `${endName} -> ${startName}`, direction: 'backward' };
                        }
                    }
                }
            }

            return null;
        }

        function doesTrajectoryPassStation(fullTrajectName, stationCode) {
            if (!fullTrajectName || !stationCode) return false;
            const trajectNames = fullTrajectName.split(' -> ');
            return trajectNames.some(name => trajectories[name] && trajectories[name].includes(stationCode));
        }

        // --- Hoofdfunctie voor Verwerking ---
        function processMessage() {
            const messageInput = document.getElementById('whatsappMessage').value;
            if (!messageInput.trim()) return;
            
            let processedMessage = messageInput;
            const targetStationName = document.getElementById('targetStationSelect').value;
            const targetStationCode = stationData.find(s => s.naam === targetStationName)?.afkorting;

            // 1. Parsen
            let parsedData = { originalMessage: messageInput, timestamp: null, route: [], routeCodes: [] };
            const timeMatch = messageInput.match(/(\d{1,2}[:.]\d{2})/g);
            if (timeMatch) parsedData.timestamp = timeMatch[0].replace('.', ':');
            
            stationData.sort((a, b) => b.afkorting.length - a.afkorting.length);
            let foundMatches = [];
            stationData.forEach(station => {
                const isConflicting = conflictingAbbrs.includes(station.afkorting.toUpperCase());
                const regex = new RegExp(`\\b(${station.afkorting})\\b(?!-)`, isConflicting ? 'g' : 'gi');
                
                let match;
                while ((match = regex.exec(messageInput)) !== null) {
                    if (!foundMatches.some(m => m.index === match.index)) {
                        foundMatches.push({ station: station, index: match.index, text: match[1] });
                    }
                }
            });
            foundMatches.sort((a, b) => a.index - b.index);
            parsedData.route = foundMatches.map(m => m.station.naam);
            parsedData.routeCodes = foundMatches.map(m => m.station.afkorting);

            // 2. Visuele vervanging
            let tempMessage = processedMessage;
            foundMatches.forEach(match => {
                tempMessage = tempMessage.replace(new RegExp(`\\b${match.text}\\b(?!-)`, 'g'), `<span class="highlight-station">${match.station.naam}</span>`);
            });
            processedMessage = tempMessage;

            for (const abbr in spotterAbbr) {
                const regex = new RegExp(`\\b${abbr}\\b(?!-)`, 'gi');
                processedMessage = processedMessage.replace(regex, (foundText) => {
                    return `<span class="highlight-abbr" title="${spotterAbbr[abbr]}">${foundText}</span>`;
                });
            }

            // 3. Traject-analyse en berekening
            let passageHtml = '';
            let timeHtml = '';
            const trajectoryAnalysis = findTrajectoryForRoute(parsedData.routeCodes);
            parsedData.trajectoryAnalysis = trajectoryAnalysis;
            
            if (trajectoryAnalysis) {
                const { name: matchedTraject, direction } = trajectoryAnalysis;
                const passesTarget = doesTrajectoryPassStation(matchedTraject, targetStationCode);
                let generalDirection = "Onbekend";
                if (direction === 'forward') {
                    if (matchedTraject.startsWith('Duitsland')) generalDirection = 'Nederland in';
                    else generalDirection = 'Westwaarts';
                } else {
                    if (matchedTraject.includes('Duitsland')) generalDirection = 'Nederland uit';
                    else generalDirection = 'Oostwaarts';
                }
                
                passageHtml = `Rijrichting: ð <strong>${generalDirection}</strong> | Passage ${targetStationName}: <strong>${passesTarget ? 'â Ja' : 'â Nee'}</strong>`;
            } else if (parsedData.route.length > 1) {
                passageHtml = "Kan geen bekend traject matchen met de gespotte route.";
            } else {
                passageHtml = "Geen route herkend in het bericht.";
            }

            if (parsedData.route.length > 0 && parsedData.timestamp) {
                const firstSpottedStationName = parsedData.route[0];
                const firstSpottedStationCode = parsedData.routeCodes[0];
                
                let hasPassed = false;
                if (trajectoryAnalysis) {
                    const { name: matchedTraject, direction } = trajectoryAnalysis;
                    const allTrajectStations = matchedTraject.split(' -> ').reduce((acc, name) => acc.concat(trajectories[name]), []);
                    
                    const spotIndex = allTrajectStations.indexOf(firstSpottedStationCode);
                    const targetIndex = allTrajectStations.indexOf(targetStationCode);

                    if (spotIndex !== -1 && targetIndex !== -1) {
                        if (direction === 'forward' && spotIndex > targetIndex) {
                            hasPassed = true;
                        } else if (direction === 'backward' && spotIndex < targetIndex) {
                            hasPassed = true;
                        }
                    }
                }

                if (hasPassed) {
                    timeHtml = `<p>Geschatte doorkomsttijd niet van toepassing (trein is station al gepasseerd).</p>`;
                } else {
                    const distance = distanceData[firstSpottedStationCode]?.[targetStationCode];
                    if (distance !== undefined) {
                        const averageSpeedKmH = 80;
                        const travelMinutes = Math.round((distance / averageSpeedKmH) * 60);
                        const [hours, minutes] = parsedData.timestamp.split(':').map(Number);
                        const spotDate = new Date();
                        spotDate.setHours(hours, minutes, 0, 0);
                        spotDate.setMinutes(spotDate.getMinutes() + travelMinutes);
                        const arrivalTime = spotDate.toTimeString().substring(0, 5);
                        timeHtml = `â° Geschatte doorkomsttijd in <span class="font-bold">${targetStationName}</span>: <strong class="highlight-estimation">${arrivalTime}</strong> <br> <span class="text-sm text-gray-600">(vanaf ${firstSpottedStationName})</span>`;
                    } else {
                        timeHtml = `<p>Geen afstandsdata gevonden tussen <span class="font-bold">${firstSpottedStationName}</span> en <span class="font-bold">${targetStationName}</span>.</p>`;
                    }
                }
            } else {
                timeHtml = `<p>Geen station of tijdstip gevonden om een berekening te maken.</p>`;
            }

            // 4. Resultaten tonen
            document.getElementById('output').innerHTML = processedMessage;
            document.getElementById('estimation-output').innerHTML = `<div>${passageHtml}</div><div>${timeHtml}</div>`;
            document.getElementById('parsed-data-output').innerHTML = `<pre>${JSON.stringify(parsedData, null, 2)}</pre>`;
        }

        // --- Hulpfuncties ---
        function debounceProcessMessage() {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(processMessage, 300);
        }

        window.onload = loadExternalData;
    </script>
</body>
</html>
