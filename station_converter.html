<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpotConverter Pro (RijdendeTreinen Stijl)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts (Open Sans) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* RijdendeTreinen.nl Kleurenpalet en Font */
        :root {
            --rt-blue: #0d2a4c;
            --rt-orange: #f37736;
            --rt-light-blue: #e6f3f9;
            --rt-gray: #f0f0f0;
            --rt-text: #333;
        }
        body { 
            font-family: 'Open Sans', sans-serif; 
            background-color: var(--rt-gray);
            color: var(--rt-text);
        }
        .rt-header {
            background-color: var(--rt-blue);
            color: white;
            border-bottom: 5px solid var(--rt-orange);
        }
        .rt-button {
            background-color: var(--rt-orange);
            color: white;
            font-weight: 700;
            transition: background-color 0.2s;
        }
        .rt-button:hover {
            background-color: #d96323;
        }
        h2 {
            color: var(--rt-blue);
            font-weight: 700;
        }
        .info-box {
            background-color: var(--rt-light-blue);
            border-left: 4px solid var(--rt-orange);
            padding: 1rem 1.5rem;
        }
        .highlight-station { background-color: #d1eaff; padding: 0.1rem 0.3rem; border-radius: 0.2rem; font-weight: bold; }
        .highlight-abbr { 
            background-color: #e2e8f0; 
            color: #475569;
            padding: 0.1rem 0.3rem; 
            border-radius: 0.2rem; 
            font-weight: 600;
            cursor: help;
            border-bottom: 2px dotted #94a3b8;
        }
        .highlight-estimation { background-color: var(--rt-orange); padding: 0.1rem 0.3rem; border-radius: 0.2rem; font-weight: bold; color: white; }
        .toggle-btn {
            background: none;
            border: none;
            color: #64748b;
            font-weight: 600;
            cursor: pointer;
        }
        .toggle-btn:hover {
            color: var(--rt-blue);
        }
    </style>
</head>
<body class="py-8">
    <div class="max-w-4xl mx-auto px-4 space-y-8">
        
        <!-- Header en Toelichting -->
        <header class="rt-header p-6 rounded-lg shadow-lg text-center">
            <h1 class="text-4xl font-bold">SpotConverter Pro</h1>
            <p class="mt-2 text-lg text-gray-200">
                Deze tool helpt je om WhatsApp-berichten van treinspotters snel te analyseren. Plak een bericht en zie direct de volledige stationsnamen, de betekenis van spotters-jargon en een inschatting van de passage-tijd voor een gekozen station.
            </p>
        </header>

        <!-- Converter Tool -->
        <main class="bg-white p-6 rounded-lg shadow-md">
            <div class="grid md:grid-cols-2 gap-6">
                <!-- Input -->
                <div>
                    <label for="whatsappMessage" class="block text-lg font-bold text-gray-700 mb-2">Plak je WhatsApp bericht hier:</label>
                    <textarea id="whatsappMessage" class="w-full h-32 border-gray-300 rounded-md shadow-sm" placeholder="Bijv. 14:00 Amf ri Asd" oninput="debounceProcessMessage()"></textarea>
                </div>
                <!-- Instellingen -->
                <div>
                    <label for="targetStationSelect" class="block text-lg font-bold text-gray-700 mb-2">Bereken passage voor:</label>
                    <select id="targetStationSelect" class="w-full border-gray-300 rounded-md shadow-sm" onchange="processMessage()"></select>
                </div>
            </div>
            
            <!-- Output secties -->
            <div class="mt-6 space-y-4">
                <div>
                    <h2 class="text-2xl mb-2">Verwerkt Bericht:</h2>
                    <div id="output" class="p-4 bg-gray-50 rounded-md min-h-[50px]"></div>
                </div>
                <div>
                    <h2 class="text-2xl mb-2">Passage Inschatting:</h2>
                    <div id="estimation-output" class="p-4 bg-gray-50 rounded-md min-h-[50px] info-box"></div>
                </div>
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <h2 class="text-2xl">Geparsede Data (voor analyse)</h2>
                        <button id="toggle-data-btn" onclick="toggleParsedData()" class="toggle-btn">(Toon)</button>
                    </div>
                    <pre id="parsed-data-output" class="p-4 bg-gray-800 text-white text-xs rounded-md overflow-x-auto" style="display: none;"></pre>
                </div>
            </div>
        </main>
        
        <!-- Informatie sectie -->
        <footer class="bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-2xl mb-4">Terugkerende Treinpatronen</h2>
            <div class="space-y-4 text-gray-800">
                 <div>
                    <h3 class="font-bold text-lg">1. De "Katy Shuttle" (RFO)</h3>
                    <p>Rijdt zeer frequent tussen Knooppunt Kijfhoek en Polen. De route van/naar Kijfhoek loopt via de spoorlijn Gouda - Woerden - Weesp - Baarn - Amersfoort en <strong>passeert dus Baarn</strong>.</p>
                </div>
                <div>
                    <h3 class="font-bold text-lg">2. De "PCC Shuttle" (RTB Cargo)</h3>
                    <p>Verbindt de Rotterdamse haven met Polen. De route van/naar de Rotterdamse haven loopt via de spoorlijn Gouda - Woerden - Weesp - Baarn - Amersfoort en <strong>passeert dus Baarn</strong>.</p>
                </div>
                <div>
                    <h3 class="font-bold text-lg">3. De "Volvo Trein" (Lineas)</h3>
                    <p>Een vaste shuttle tussen Gent (BelgiÃ«) en Zweden. Deze trein <strong>passeert Baarn niet</strong>, de route loopt zuidelijker via de Betuweroute.</p>
                </div>
                <div>
                    <h3 class="font-bold text-lg">4. De "UC Onnen" & "UC Buna Werke" (DB Cargo)</h3>
                    <p>Dit zijn keteltreinen van DB Cargo. Deze treinen <strong>passeren Baarn niet</strong>.</p>
                </div>
            </div>
        </footer>

    </div>

    <script>
        // --- Globale variabelen en Constanten ---
        let stationData = [], distanceData = {}, trajectories = {}, debounceTimer;
        const spotterAbbr = {
            'A': 'Aankomst', 'V': 'Vertrek', 'D': 'Doorrijden',
            'LSP': 'Linkerspoor', 'LLSP': 'Linker-linkerspoor', 'MSP': 'Middenspoor',
            'RSP': 'Rechterspoor', 'RRSP': 'Rechter-rechterspoor',
            'NVR': 'Niet voor reizigers', 'LM': 'Leeg materieel', 'LLT': 'Losse loc trein',
            'SMS': 'Samenstelling', 'GE': 'Goederenemplacement', 'Badl': 'Beladen aan de loc'
        };
        const conflictingAbbrs = ['EN', 'DE', 'D', 'A', 'V'];

        // --- Data Laden ---
        async function loadExternalData() {
            try {
                // Stations
                const stationsUrl = 'https://raw.githubusercontent.com/meijbaard/SpotConverter/main/stations.csv';
                const stationResponse = await fetch(stationsUrl);
                if (!stationResponse.ok) throw new Error(`Fout bij laden stations.csv: ${stationResponse.statusText}`);
                const stationCsvText = await stationResponse.text();
                const stationLines = stationCsvText.trim().split('\n');
                const stationHeaders = stationLines.shift().split(',').map(h => h.trim());
                const codeIndex = stationHeaders.indexOf('code');
                const nameLongIndex = stationHeaders.indexOf('name_long');
                if (codeIndex === -1 || nameLongIndex === -1) throw new Error("Kolommen 'code' en 'name_long' niet gevonden in stations.csv");
                stationData = stationLines.map(line => {
                    const values = line.split(',');
                    return { afkorting: values[codeIndex].trim().toUpperCase(), naam: values[nameLongIndex].trim().replace(/"/g, '') };
                });
                populateStationDropdown();

                // Afstanden
                const distancesUrl = 'https://raw.githubusercontent.com/meijbaard/SpotConverter/main/afstanden.csv';
                const distanceResponse = await fetch(distancesUrl);
                if (!distanceResponse.ok) throw new Error(`Fout bij laden afstanden.csv: ${distanceResponse.statusText}`);
                const distanceCsvText = await distanceResponse.text();
                const distanceLines = distanceCsvText.trim().split('\n');
                const distanceHeaders = distanceLines.shift().split(',').map(h => h.trim().toUpperCase());
                distanceData = {};
                distanceLines.forEach(line => {
                    const values = line.split(',');
                    const rowStationCode = values.shift().trim().toUpperCase();
                    distanceData[rowStationCode] = {};
                    values.forEach((dist, index) => {
                        const colStationCode = distanceHeaders[index + 1];
                        if (colStationCode) {
                            distanceData[rowStationCode][colStationCode] = parseFloat(dist);
                        }
                    });
                });
                
                // Trajecten
                trajectories = {
                    "Duitsland-Amersfoort": ["RHEINE", "SALZBERGEN", "BH", "ODZ", "HGLO", "HGL", "BN", "AMRI", "AML", "WDN", "RSN", "HON", "DVC", "DV", "TWL", "APDO", "APD", "STO", "BNVA", "BNV", "AMF"],
                    "Amersfoort-Amsterdam": ["AMF", "BRN", "HVS", "HVSM", "BSMZ", "NDB", "WP", "DMN", "ASSP", "ASDM", "ASD", "AWH"],
                    "Amersfoort-Rotterdam": ["AMF", "BRN", "HVS", "HVSM", "BSMZ", "NDB", "WP", "DMNZ", "ASB", "BKL", "WD", "GD", "RTN", "RTD"]
                };

            } catch (error) {
                console.error("Kon externe data niet laden:", error);
                document.getElementById('output').innerHTML = `<p class="warning">Kon de data van GitHub niet laden: ${error.message}</p>`;
            }
        }
        
        // --- UI Functies ---
        function populateStationDropdown() {
            const select = document.getElementById('targetStationSelect');
            select.innerHTML = '';
            stationData.sort((a,b) => a.naam.localeCompare(b.naam)).forEach(station => {
                const option = document.createElement('option');
                option.value = station.naam;
                option.textContent = station.naam;
                if (station.naam === "Baarn") option.selected = true;
                select.appendChild(option);
            });
        }

        function toggleParsedData() {
            const dataOutput = document.getElementById('parsed-data-output');
            const toggleBtn = document.getElementById('toggle-data-btn');
            const isHidden = dataOutput.style.display === 'none';
            dataOutput.style.display = isHidden ? 'block' : 'none';
            toggleBtn.textContent = isHidden ? '(Verberg)' : '(Toon)';
        }

        // --- Logica ---
        // ** VERNIEUWDE FUNCTIE **
        function findTrajectoryForRoute(routeCodes) {
            if (routeCodes.length < 2) return null;

            const isSubsequence = (sub, main) => {
                let i = 0, j = 0;
                while (i < main.length && j < sub.length) {
                    if (main[i] === sub[j]) j++;
                    i++;
                }
                return j === sub.length;
            };

            // Case 1: Check for a direct match within a single trajectory first.
            for (const name in trajectories) {
                const traject = trajectories[name];
                if (isSubsequence(routeCodes, traject) || isSubsequence(routeCodes, [...traject].reverse())) {
                    return name; // Found the most direct route.
                }
            }

            // Case 2: If no direct match, check for a route spanning two trajectories via the "AMF" hub.
            const startCode = routeCodes[0];
            const endCode = routeCodes[routeCodes.length - 1];
            const hub = "AMF";

            const startTrajectNames = Object.keys(trajectories).filter(name => trajectories[name].includes(startCode));
            const endTrajectNames = Object.keys(trajectories).filter(name => trajectories[name].includes(endCode));

            for (const startName of startTrajectNames) {
                for (const endName of endTrajectNames) {
                    if (startName === endName) continue;

                    const startTraj = trajectories[startName];
                    const endTraj = trajectories[endName];

                    if (startTraj.includes(hub) && endTraj.includes(hub)) {
                        if (isSubsequence([startCode, hub], startTraj) && isSubsequence([hub, endCode], endTraj)) {
                            return `${startName} -> ${endName}`;
                        }
                         if (isSubsequence([startCode, hub], endTraj) && isSubsequence([hub, endCode], startTraj)) {
                            return `${endName} -> ${startName}`;
                        }
                    }
                }
            }

            return null;
        }

        function doesTrajectoryPassStation(fullTrajectName, stationCode) {
            if (!fullTrajectName || !stationCode) return false;
            const trajectNames = fullTrajectName.split(' -> ');
            return trajectNames.some(name => trajectories[name] && trajectories[name].includes(stationCode));
        }

        // --- Hoofdfunctie voor Verwerking ---
        function processMessage() {
            const messageInput = document.getElementById('whatsappMessage').value;
            if (!messageInput.trim()) return;
            
            let processedMessage = messageInput;
            const targetStationName = document.getElementById('targetStationSelect').value;
            const targetStationCode = stationData.find(s => s.naam === targetStationName)?.afkorting;

            // 1. Parsen
            let parsedData = { originalMessage: messageInput, timestamp: null, route: [], routeCodes: [] };
            const timeMatch = messageInput.match(/(\d{1,2}[:.]\d{2})/g);
            if (timeMatch) parsedData.timestamp = timeMatch[0].replace('.', ':');
            
            stationData.sort((a, b) => b.afkorting.length - a.afkorting.length);
            let foundMatches = [];
            stationData.forEach(station => {
                const isConflicting = conflictingAbbrs.includes(station.afkorting.toUpperCase());
                const flags = isConflicting ? 'g' : 'gi';
                const regex = new RegExp(`\\b${station.afkorting}\\b`, flags);
                
                let match;
                while ((match = regex.exec(messageInput)) !== null) {
                    if (!foundMatches.some(m => m.index === match.index)) {
                        foundMatches.push({ station: station, index: match.index });
                    }
                }
            });
            foundMatches.sort((a, b) => a.index - b.index);
            parsedData.route = foundMatches.map(m => m.station.naam);
            parsedData.routeCodes = foundMatches.map(m => m.station.afkorting);

            // 2. Visuele vervanging
            foundMatches.forEach(match => {
                const isConflicting = conflictingAbbrs.includes(match.station.afkorting.toUpperCase());
                const flags = isConflicting ? 'g' : 'gi';
                processedMessage = processedMessage.replace(new RegExp(`\\b${match.station.afkorting}\\b`, flags), `<span class="highlight-station">${match.station.naam}</span>`);
            });

            for (const abbr in spotterAbbr) {
                const regex = new RegExp(`\\b${abbr}\\b`, 'gi');
                processedMessage = processedMessage.replace(regex, (foundText) => {
                    return `<span class="highlight-abbr" title="${spotterAbbr[abbr]}">${foundText}</span>`;
                });
            }

            // 3. Traject-analyse en berekening
            let estimationHtml = '<p>Geen route of tijdstip herkend in het bericht.</p>';
            const matchedTraject = findTrajectoryForRoute(parsedData.routeCodes);
            parsedData.matchedTraject = matchedTraject;

            if (matchedTraject) {
                const passesTarget = doesTrajectoryPassStation(matchedTraject, targetStationCode);
                if (passesTarget) {
                    if (parsedData.route.length > 0 && parsedData.timestamp) {
                        const firstSpottedStationName = parsedData.route[0];
                        const firstSpottedStationCode = parsedData.routeCodes[0];

                        const distance = distanceData[firstSpottedStationCode]?.[targetStationCode];

                        if (distance !== undefined) {
                            const averageSpeedKmH = 80;
                            const travelMinutes = Math.round((distance / averageSpeedKmH) * 60);
                            const [hours, minutes] = parsedData.timestamp.split(':').map(Number);
                            const spotDate = new Date();
                            spotDate.setHours(hours, minutes, 0, 0);
                            spotDate.setMinutes(spotDate.getMinutes() + travelMinutes);
                            const arrivalTime = spotDate.toTimeString().substring(0, 5);
                            estimationHtml = `Vermoedelijke passage <span class="font-bold">${targetStationName}</span>: <strong class="highlight-estimation">${arrivalTime} +/- 15min</strong> <br> <span class="text-sm text-gray-600">(Route: ${matchedTraject})</span>`;
                        } else {
                            estimationHtml = `<p>Route passeert ${targetStationName}, maar geen afstandsdata gevonden vanaf <span class="font-bold">${firstSpottedStationName}</span>.</p>`;
                        }
                    } else {
                        estimationHtml = `<p>Route passeert ${targetStationName}, maar er is geen tijdstip gevonden in het bericht om een berekening te maken.</p>`;
                    }
                } else {
                    estimationHtml = `<strong>Trein rijdt vermoedelijk niet langs ${targetStationName}.</strong><br><span class="text-sm text-gray-600">(Gevonden route: ${matchedTraject})</span>`;
                }
            } else if (parsedData.route.length > 1) {
                estimationHtml = "<p>Kan geen bekend traject matchen met de gespotte route.</p>";
            }

            // 4. Resultaten tonen
            document.getElementById('output').innerHTML = processedMessage;
            document.getElementById('estimation-output').innerHTML = estimationHtml;
            document.getElementById('parsed-data-output').innerHTML = `<pre>${JSON.stringify(parsedData, null, 2)}</pre>`;
        }

        // --- Hulpfuncties ---
        function debounceProcessMessage() {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(processMessage, 300);
        }

        window.onload = loadExternalData;
    </script>
</body>
</html>
